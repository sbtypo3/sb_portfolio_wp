<?php
 	/*  
 		Copyright 2017  Stephen Bungert  (email : hello@stephenbungert.com)
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License, version 2, as 
	    published by the Free Software Foundation.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
	*/
	
	
	
	/**
	 * Utility functions for SB Portfolio.
	 * 
	 * @author Stephen Bungert <hello@stephenbungert.com>
	 * @package WordPress
	 * @subpackage SB Portfolio
	 * @since 0.1.0
	 */
	class Sbp_PluginBase {
		// Sbp_PluginBase::debug();
		// Sbp_PluginBase::explodeAndTrim();
		// Sbp_PluginBase::isSbpPost();
		
		/**
		 * The maximum depth for debugging so as to avoid infinite recursion.
		 *
		 * @since 0.1.0
		 * @access protected
		 * @var string
		 */
		const MAX_DEBUG_DEPTH = 100;
		
		/**
		 * The content generated by debug.
		 *
		 * @since 0.1.0
		 * @access protected
		 * @var string
		 */
		protected static $debugContent = '';
		
		/**
		 * Gets a $_POST or $_GET var.
		 *
		 * @since 0.1.0
		 * @access protected
		 * @param string $var The name of the GET or POST var to be returned.
		 * @param string $varSrc The type of var, either "get" or "post".
		 * @return $value The GET or POST var value.
		 */
		protected static function varFind($var, $varSrc = 'get') {
			$value		= '';
			$varFound	= FALSE;
			
			if ($varSrc != 'get' && $varSrc != 'post') {
				$varSrc = 'get';
			}
			
			if ($varSrc == 'post') {
				if (isset($_POST[$var]) && !empty($_POST[$var])) {
					$value = $_POST[$var];
					$varFound = TRUE;
				}
				
			} else {
				if (isset($_GET[$var]) && !empty($_GET[$var])) {
					$value = $_GET[$var];
					$varFound = TRUE;
				}
			}
			
			if ($varFound) {
				if (is_array($value)) {
					self::stripSlashesRecursive($value);
					
				} else {
					$value = stripSlashes($value);
				}
			}
			
			return $value;
		}
		
		/**
		 * Gets the plugin's variables from POST and GET.
		 *
		 * @since 0.1.0
		 * @access public
		 * @return string The current page render mode;
		 */
		public static function getPluginVars() {
			$pluginVarsPost	= Sbp_PluginBase::varPost(SBP_VARS);
			$pluginVarsGet	= Sbp_PluginBase::varGet(SBP_VARS);
			$pluginVars		= array();
			
				// They should be an array... if not make an empty array
			if (!is_array($pluginVarsPost)) {
				$pluginVarsPost	= array();
			}
			
			if (!is_array($pluginVarsGet)) {
				$pluginVarsGet	= array();
			}
			
			if (!empty($pluginVarsPost) && !empty($pluginVarsGet)) {
				$pluginVars = array_merge_recursive($pluginVarsPost, $pluginVarsGet);
				
			} else if (empty($pluginVarsPost) && !empty($pluginVarsGet)) {
				$pluginVars = $pluginVarsGet;
				
			} else if (!empty($pluginVarsPost) && empty($pluginVarsGet)) {
				$pluginVars = $pluginVarsPost;
			}
			
			Sbp_PluginBase::stripSlashesRecursive($pluginVars);
			
			return $pluginVars;
		}
		
		/**
		 * Gets a $_POST var.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param string $var The name of the POST var to be returned.
		 * @return $value The POST var value.
		 */
		public static function varPost($var = '') {
			$value = '';
			
			if (is_string($var)) $value = self::varFind($var, 'post');
			
			return $value;
		}
		
		/**
		 * Gets a $_GET var.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param string $var The name of the GET var to be returned.
		 * @return $value The GET var value.
		 */
		public static function varGet($var = '') {
			$value = '';
			
			if (is_string($var)) $value = self::varFind($var);
			
			return $value;
		}
		
		/**
		 * Gets a var, checking first in POST and then GET.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param string $var The name of the GET var to be returned.
		 * @return $value The GET var value.
		 */
		public static function varSubmitted($var = '') {
			$value = '';
			
			if (is_string($var)) {
				$value = self::varFind($var, 'post');
				
				if ($value == '') $value = self::varFind($var);
			}
			
			return $value;
		}
		
		/**
		 * Goes through an array calling stripslashes()
		 * 
		 * @since 0.1.0
		 * @access public
		 * @param array $targetArray An array value to strip recursively, or a string.
		 * @return void.
		 */
		public static function stripSlashesRecursive(array $targetArray) {
			foreach ($targetArray as &$value) {
				if (is_array($value)) {
					self::stripSlashesRecursive($value);
				} else {
					$value = stripslashes($value);
				}
			}
			
			unset($value);
			reset($targetArray);
		}
		
		/**
		 * Returns a comma sep. list of integers ready for a SQL query (for IN() for example).
		 * $intList can be an array of values or a suspect comma sep. list of integers.
		 * They will processed, intval'ed and made in to a string with duplicates removed.
		 * 
		 * @since 0.1.0
		 * @access public
		 * @param mixed $intList A string or an array containing integers.
		 * @return string $cleanedResult A comma sep. list of integers.
		 */
		public static function cleanIntList($intList) {
			$cleanedResult = '0';
			
			if (is_string($intList)) {
				$intList = explode(',', $intList);
			}
			
			if (is_array($intList)) {
				$cleanIntList = array();
				
				foreach ($intList as $intValue) {
					if (!empty($intValue)) {
						$cleanIntList[] = intval($intValue);
					}
				}
				
				if (!empty($cleanIntList)) {
					$cleanIntList	= array_unique($cleanIntList);
					$cleanedResult	= implode(',', $cleanIntList);
				}
			} // Else, if not now an array, return 0 so as not to stop queries
			
			return $cleanedResult;
		}
		
		/**
		 * Converts a timestamp to a format useable by mysql2date().
		 * 
		 * @since 0.1.0
		 * @access public
		 * @param string $timestamp A timestamp to format.
		 * @return string $timestamp The timestamp ready to be used in mysql2date().
		 */
		public static function convertTimestamp($timestamp) {
			return date('Y-m-d H:i:s', $timestamp);
		}
		
		/**
		 * Explodes an array and trims the values.
		 * 
		 * @since 0.1.0
		 * @access public
		 * @param string $stringToExplode A string that needs turning into an array.
		 * @param string $delimiter A sub string to split the string into an array with.
		 * @param boolean $removeEmptyValues Only non-emty values will be returned in the array if this is TRUE.
		 * @return array $explodedString The exploded string.
		 */
		public static function explodeAndTrim($stringToExplode, $delimiter = ',', $removeEmptyValues = TRUE) {
			$explodedString = explode($delimiter, $stringToExplode);
			$explodedString = array_map('trim', $explodedString);
			
			if ($removeEmptyValues) {
				$explodedString = array_filter($explodedString);
			}
			
			return $explodedString;
		}
		
		/**
		 * Echos a table with information about a var/an object.
		 * 
		 * @since 0.1.0
		 * @access public
		 * @param mixed $var Whatever it is that needs debugging
		 * @param string $title A title for the debug.
		 * @param boolean $echo Should the output be echoed. If FALSE it will be returned as a string,
		 * @return mixed Either nothing or a string if $echo !== TRUE
		 */
		public static function debug($var, $title = '', $echo = TRUE) {
			self::$debugContent = self::debugIt($var, 1, $title);
			
			if ($echo !== TRUE) {
				return self::$debugContent;
				
			} else {
				if (!empty(self::$debugContent)) echo self::$debugContent;
			}
		}
		
		/**
		 * A recursive function that returns information about a var/an object.
		 * 
		 * @since 0.1.0
		 * @access protected
		 * @param mixed $var Whatever it is that needs debugging
		 * @param integer $currentDepth The number of calls to this function that this call is, increases wih each call.
		 * @param string $title A title for the debug.
		 * @return string $outputContent The output for the current $var;
		 */
		protected static function debugIt($var, $currentDepth, $title = '') {
			$varType = gettype($var);
			
			if ($varType == 'array' || $varType == 'object') {
				$typeHeader = 'Key';
				
				if ($varType == 'object') $typeHeader = 'Property';
				
				$outputContent	 = '';
				
				if ($currentDepth == 1) {
					$outputContent .= '<table class="sbpDebugTable sbpDebugTable-base">';
					
				} else {
					$outputContent .= '<table class="sbpDebugTable sbpDebugTable-' . $currentDepth . '">';
				}
				
				$outputContent	.= '<thead>';
				
				if ($title != '') $outputContent .= '<tr><th class="debugTitle" colspan="3">' . $title . '</th></tr>';
				
				$outputContent	.= '<tr><th>' . $typeHeader . '</th><th>Type</th><th>Value</th></tr>';
				$outputContent	.= '</thead>';
				$outputContent	.= '<tbody>';
				
				foreach ($var as $key => $value) {
					$objectHasProperties	= FALSE;
					$keyType				= gettype($value);
					
					$outputContent .= '<tr><td class="keyCell">';
					$outputContent .= $key;
					$outputContent .= '</td><td class="typeCell">';
					$outputContent .= $keyType;
					
					if ($keyType == 'string' && $value != '') {
						$outputContent .= ' <span class="typeInfo">(' . mb_strlen($value) . ')</span>';
						
					} else if ($keyType == 'array' && !empty($value)) {
						$outputContent .= ' <span class="typeInfo">(' . count($value) . ')</span>';
						
					} else if ($keyType == 'object') {
						$objectHasProperties	= get_object_vars($value);
						$numberOfProperties		= count($objectHasProperties);
						
						if ($numberOfProperties > 0) {
							$outputContent .= ' <span class="typeInfo">(' . $numberOfProperties . ')</span>';
						}
					}
					
					$outputContent .= '</td><td class="valueCell">';
					
					if ($keyType == 'array' || $keyType == 'object') {
						if ($keyType == 'object') {
							$outputContent .= '<span class="classInfo">' . get_class($value) . '</span><br />';
						}
						
						if (($keyType == 'array' && !empty($value)) || $objectHasProperties) {
							if ($currentDepth < self::MAX_DEBUG_DEPTH) {
								$newDepth = $currentDepth + 1;
								$outputContent .= self::debugIt($value, $newDepth);
							}
							
						} else {
							$outputContent .= '<span class="emptyValue">EMPTY!</span>';
						}
						
					} else {
						$outputContent .= self::debugGetStandardType($value, $keyType);
					}
					
					$outputContent .= '</td></tr>';
				}
				
			} else {
				$outputContent	= '<table class="sbpDebugTable sbpDebugTable-base"><thead>';
				
				if ($title != '') $outputContent .= '<tr><th class="debugTitle" colspan="3">' . $title . '</th></tr>';
				
				$outputContent.= '<tr><th>Type</th><th colspan="2">Value</th></tr>';
				$outputContent.= '</thead><tbody>';
				$outputContent .= '<tr><td class="typeCell">' . $varType . '</td><td colspan="2" class="valueCell">';
				$outputContent .= self::debugGetStandardType($var, $varType);
			}
					
			$outputContent .= '</td></tr>';
			$outputContent .= '</tbody></table>';
			
			return $outputContent;
		}
		
		/**
		 * Returns a string representation of a variable, based on the type of variable (not arrays or objects)
		 * 
		 * @since 0.1.0
		 * @access protected
		 * @param mixed $var Whatever it is that needs debugging.
		 * @param string $varType What $var is.
		 * @return string $type The string representation of $varType.
		 */
		protected static function debugGetStandardType($var, $varType) {
			$type = '';
			
			switch ($varType) {
				case 'resource':
					$type =  get_resource_type($var);
					
				case 'NULL':
					$type = 'NULL';
					
					break;
					
				case 'boolean':
					if ($var === TRUE) {
						$type = 'TRUE';
					} else {
						$type = 'FALSE';
					}
					
					break;
					
				case 'double':
				case 'string':
				case 'integer':
					if ($varType == 'string') {
						if ($var == '') {
							$type = '<span class="emptyValue">EMPTY!</span>';
							
						} else {
							$type = htmlspecialchars($var);
						}
						
					} else {
						$type = $var;
					}
					
					break;
					
				case 'unknown type':
				default:
					$type = 'TYPE UNKNOWN';
					
					break;
			}
			
			return $type;
		}
		
		
		
		/**
		 * Array filter methods.
		 */

		/**
		 * Used to filter array elements out that contain 'sbp_'.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param string $eleVal A value from an array.
		 * @return boolean
		 */
		public static function arrayFilterOutSbp($eleVal) {
  			return strpos($eleVal, 'sbp_') === false;
		}

		/**
		 * Used to filter array elements out that don't contain 'sbp_'.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param string $eleVal A value from an array.
		 * @return boolean
		 */
		public static function arrayFilterOutNonSbp($eleVal) {
  			return !self::arrayFilterOutSbp($eleVal);
		}

		/**
		 * Returns TRUE if the $post's post type is an SBP post type.
		 * Optionally you can also check that it is a certain type of SBP post.
		 * $post can also be a string, in which case this is checked.
		 *
		 * @since 0.1.0
		 * @access public
		 * @param mixed $postType The post object or a post object's type.
		 * @param string $postTypeReq The post object.
		 * @return boolean $isValid.
		 */
		public static function isSbpPost($post, $postTypeReq = '') {
			$isValid = FALSE;
			
  			if (!empty($post)) {
  				if (is_string($post) && strpos($post, 'sbp_') !== FALSE) {
		  				$isValid = TRUE;
  					
  				} else {
		  			if (!empty($postTypeReq)) {
		  				$reqTypes = self::explodeAndTrim($postTypeReq, '|');
		  				
		  				if (!empty($reqTypes)) {
		  					foreach ($reqTypes as $type) {
		  						if ($post->post_type == 'sbp_' . $type) {
		  							$isValid = TRUE;
		  							break;
		  						}
		  					}
		  				}
		  				
		  			} else if (strpos($post->post_type, 'sbp_') !== FALSE) {
		  				$isValid = TRUE;
		  			}
  				}
  			}
  				
  			return $isValid;
		}
	}
?>